// +build ignore

package main

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strconv"
	"text/template"

	"github.com/360EntSecGroup-Skylar/excelize"
)

// https://www.bfs.admin.ch/bfs/de/home/statistiken/regionalstatistik/regionale-portraets-kennzahlen/gemeinden.assetdetail.11587763.html
// WorkSheet: T21.2.1 (there is only one)
// Columns: A GemeindeID, B: GemeindeName, C: Einwohner
var pouplationMunicipalityListURL = "https://www.bfs.admin.ch/bfsstatic/dam/assets/11587763/master"

// https://www.bfs.admin.ch/bfs/de/home/grundlagen/agvch.assetdetail.15264524.html
// WorkSheet: GDE
// Columns: A Kanton, B BezirkID, C GemeindeID, D GemeindeName, F Bezirkname
var municipalityCantonListURL = "https://www.bfs.admin.ch/bfsstatic/dam/assets/15264524/master"

var outputFile = "municipality_list.go"

var packageTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.

package conav

var Municipalities = []Municipality{
{{- range .Municipalities }}
	{ {{ .ID }}, {{ printf "%q" .Name }}, {{ .Population }}, {{ printf "%q" .Canton }} },
{{- end }}
}
`))

func main() {
	err := run()
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

type municipality struct {
	ID         int
	Name       string
	Population int
	Canton     string
}

func run() error {
	resp, err := http.Get(pouplationMunicipalityListURL)
	if err != nil {
		return err
	}

	if resp.StatusCode >= 400 {
		return fmt.Errorf("failed to download populations http code: %d", resp.StatusCode)
	}

	populations, err := readPopulations(resp.Body)
	if err != nil {
		return err
	}

	resp, err = http.Get(municipalityCantonListURL)
	if err != nil {
		return err
	}

	if resp.StatusCode >= 400 {
		return fmt.Errorf("failed to download municipality list http code: %d", resp.StatusCode)
	}

	municipalities, err := readMunicipalities(resp.Body, populations)
	if err != nil {
		return err
	}

	var output = &bytes.Buffer{}
	err = packageTemplate.Execute(output, struct {
		Municipalities []municipality
	}{
		Municipalities: municipalities,
	})
	if err != nil {
		return err
	}

	// formattedOutput, err := format.Source(output.Bytes())
	// if err != nil {
	// 	return err
	// }

	formattedOutput := output.Bytes()

	err = ioutil.WriteFile(outputFile, formattedOutput, 0644)
	if err != nil {
		return err
	}
	return nil
}

func readMunicipalities(xlsxFile io.Reader, populations map[int]int) ([]municipality, error) {
	xlsx, err := excelize.OpenReader(xlsxFile)
	if err != nil {
		return nil, err
	}

	rows := xlsx.GetRows("GDE")
	dataRow := false
	municipalities := []municipality{}
	for i, row := range rows {
		if !dataRow && row[2] == "1" {
			dataRow = true
		}
		if !dataRow {
			continue
		}
		if dataRow && row[0] == "" {
			break
		}

		canton := row[0]
		name := row[3]
		id, err := strconv.Atoi(row[2])
		if err != nil {
			return nil, fmt.Errorf("failed to parse id in row %d: %w", i+1, err)
		}
		population, ok := populations[id]
		if !ok {
			log.Printf("population for municipality name=%s id=%d not found in row %d", name, id, i+1)
			continue
		}
		municipalities = append(municipalities, municipality{
			ID:         id,
			Name:       name,
			Canton:     canton,
			Population: population,
		})
	}
	return municipalities, nil
}

// readPopulation returns a map which maps municipality ids to population
func readPopulations(xlsxFile io.Reader) (map[int]int, error) {
	xlsx, err := excelize.OpenReader(xlsxFile)
	if err != nil {
		return nil, err
	}

	sheetName := xlsx.GetSheetName(1)
	if sheetName == "" {
		return nil, fmt.Errorf("failed to get sheet name")
	}

	rows := xlsx.GetRows(sheetName)
	dataRow := false
	municipalities := map[int]int{}
	for i, row := range rows {
		if !dataRow && row[0] == "1" {
			dataRow = true
		}
		if !dataRow {
			continue
		}
		if dataRow && row[0] == "" {
			break
		}

		id, err := strconv.Atoi(row[0])
		if err != nil {
			return nil, fmt.Errorf("failed to parse id in row %d: %w", i+1, err)
		}
		population, err := strconv.Atoi(row[2])
		if err != nil {
			return nil, fmt.Errorf("failed to parse population in row %d: %w", i+1, err)
		}
		municipalities[id] = population
	}
	return municipalities, nil
}
